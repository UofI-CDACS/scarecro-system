# Updating Configurations from a Data Store 
The configurations for a given SCARECRO system can become complex in large systems. This article disusses the configuration and implementation of an updater class that can handle this functionality.  



## Configuration of the Updater Class 
The updater is used to update the configurations in the system.  It should be configured as a dictionary of the following form:

    {
        folder: {
            config_name: config_id
        }
    }

Where the folder is replaced by the name of one of the folders in the config files, and the config_name is replaced by a config name in that folder, and the config id refers to some unique identifier the updater logic can use to update that particular config when necessary. 

For example: 

    {
        "addresses": {
            "bmp280_in": "bmp280_in_gateway"
        },
        "carriers": {
            "underlying_system": "underlying_system_gateway"
        },
        "handlers": {
            "switchdoc_handler": "switchdoc_sensors_gateway"
        },
        "messages": {
            "bmp280_message": "bmp280",
            "default_sensor_message": "default_sensor"
        }
    }


## General Updater Flow
We have left the update process mostly to the mercy of the programmer, since updating configurations is mostly a direct process from the data store to the configuration folder. However, we will define some of the important data structures and discuss a likely control flow for updating. 

## 4 Updated Messages
There are 3 types of update messages the system understands, and are recommended to be used by programmers. There are: 

- remote_config_updated

- fetched_config

- local_config_updated

### remote_config_updated Message
This message is generated by some entity when a config in the remote storage is changed or added. 
This message content takes the form: 

    {
        id: id of entity sending message 
        time: time_of_update
        config_folder: folder for config
        config_name: name of the config
        config_id: id of the config
    }

For example:

    {
        id: system_middle_agent_test
        time: TODO
        config_folder: addresses
        config_name: bmp280_in
        config_id: bmp280_in_gateway 
    }

### fetched_config Message
The fetched config message is very similar to the remote_config_updated message, except that it also includes the config_content

    {
        id: id of entity sending the message 
        time: time_of_update
        config_folder: folder for config
        config_name: name of the config
        config_id: id of the config
        config_content: {the dictionary content of the config }
    }

For example: 

    {
        id: system_middle_agent_test
        time: TODO
        config_folder: addresses
        config_name: bmp280_in
        config_id: bmp280_in_gateway 
        config_content: {...}
    }

### local_config_updated Message
This message indicates that the updated config was written to a local storage. The message contains:

    {
        id: id of the system who wrote the config to storage
        time: time of message generation 
        config_folder: folder of the config
        config_name: name of the config 
        config_id: id of the config
    }

    For example:

    {
        id: test_system
        time: <TODO: Fill in >
        config_folder: addresses
        config_name: bmp280_in
        config_id: bmp_280_in
    }


## Suggested Control Flow 
Here is the control we suggest for an update system, and which we have implemented in MongoDB and MQTT.
1. When a config is changed, the remote_config_updated message is sent to the middle agent. If a config is added and/or an updater changed, these messages would ideally go through first. We recommend sending to the middle agent via MQTT

2. The remote_config_updated message should have an "on_message" trigger which activates a function that can get the updated config (like mongo). This same function posts a "fetched_config" message when completed. 

3. The "fetched_config" config message should have an on_message trigger to send it via mqtt to the gateways.

4. The "fetched_config" config message should have an on_message task trigger when received by the gateway to activate the update_config function. This function should check if the gateway cares about the message (in updater config). If it does, it should write the new config to file and if successful, it should post local_config_updated message. 

5. The local_config updated message should have an on_message trigger on the gateway to send back to the middle agent. 

6. (TODO) The local_config updated message should have an on_message trigger on the middle agent to store in the database 


## Specific Implementation - Updater Tasks
There are two tasks that would need to be implemented to use Updater functionality. The first is **fetch_updates** and the other is **update_config**. 

### fetch_updates Task

The fetch_updates task is configured here:

    {
        "source_type": "carrier",
        "config_name": "mongodb_cloud",
        "function": "fetch_configurations",
        "arguments": {},
        "duration": "on_message",
        "message_type": "remote_config_updated" 
    }

In this case, we are implementing the functionality with MongoDB cloud. It triggers on receipt of the "remote_config_updated" message (the implementation of which is left to the user, depending on the database or control flow they are using). This triggers the **fetch_configuration()** function of the MongoDB carrier. This function does the following: 
- Picks up the message(s)
- Grabs the config folder, name, and id from the message 
- Queries to get the configuration 
- If the configuration is found:
    - generates a fetched_config message
    - posts it to the system 

## update_config Task
The update_config task is configured here: 

    {
        "source": "update_system",
        "function": "update_files",
        "arguments": {},
        "duration": "on_message",
        "message_type": "fetched_config" 
    }

This functionality is implemented with the updater class, and is triggered by a "fetched_config" message. This triggers the "update_files function" of the "update_stystem" class in the tasks source folder. This function does the following:
- Checks to see if a backup of the current configuration is needed. If there is not an update already pending, it will backup the current configuration to a folder ("generated_files/backup_configs/")
- grab the configured system updater from the system. This directly uses the "return_system_updater()" from the system class. 
- gets all the configuration identifying keys from the "fetched_config" message
- checks the configuration identifying keys with the written updated identifying keys 
- if they match, the configuration is updated, and:
    - the new configuration is written to file
    - if that operation is successful:
        - the system variable for a pending update is set to True using the set_system_updated() function of the system class instance. 
        - a "local_config_updated" message is posted to the system.

**NOTE**: At the moment, the system_updated variable in the system class does not do anything, and no actions are taken based on this. Updates must wait for a reboot of the system to take effect, although you could write another task which periodically checks this. 

**NOTE**: Currently no implemented action for the "local_config_updated" message. 

TODO: It would be a good idea to write a task that uses the previous config if the current config (after an update) causes the system to fail. 

## Needed Configurations for Implementation 
**Note** - You will need the configurations stored in your database. We use MongoDB cloud for our case. The triggered message for remote_config_updated does not yet have a default implementation. 

**Gateway**
Messages:
- fetched_config
- local_config_updated

Addresses:
- cloud_mqtt_receive (or something similar you will receive the "fetched_config" message on)

Carriers:
- mqtt_cloud (to receive fetched_config message send local_config updated message)

Tasks:
- update_config

**Middle Agent/Data Store**
Messages:
- remote_config_updated
- fetched_config
- local_config_updated

Addresses:
- cloud_mqtt_receive (or something similar you will receive the "fetched_config" message on)
- mqtt_cloud_send (or something similar to send the "fetched_config" message on)
- (maybe) mongo_cloud_immediate (may want to store the local_config_updated message in the datastore)

Carriers:
- mqtt_cloud (to receive fetched_config message send local_config updated message)
- mongodb_cloud (to handle the fetching of the new configs) 

Tasks:
- fetch_updates (get the new configs)
- update_config (update own configs)

In this configuration, the middle agent would be in charge of fetching all new configs, sending the fetched config messages back to the gateways, and updating it's own config as needed. 


## Tests 
- test_update 



## Tips and Limitations 
- If the system updater configuration changes, it would have to change first and separately (be loaded into the system for the next update).

- In general, the only two configurations which might be unique across systems would be that system's configuration and that system's updater. 

- To run a successful update, you would already need the necessary configurations for your updater logic. We recommend having a base install of configurations first, instead of relying exclusively on a updater to pull in initial configurations. 


TODO: Add Visualizations 