# Updater

The updater is used to update the configurations in the system. 
It should be configured as a dictionary of the following form:

    {
        folder: {
            config_name: config_id
        },
    }

Where the folder is replaced by the name of one of the folders in the config files, and the config_name is replaced by a config name in that folder, and the config id refers to some unique identifier the updater logic can use to update that particular config when necessary. 

    For example: 

    config = {
        "addresses": {
            "bmp280_in": 200,
            "aqi_in": 180
        },
        "carriers": {
            "mqtt_cloud": 10,
        },
        "handlers": {
            "switchdoc_sensors": 10,
        },
        "messages":{
            "bmp280": 5,
        },
        "other": {
            "other_thing": 3,
        },
        "system": {
            "system": 0,
        },
        "tasks": {
            "fan_check": 1, 
        },
        "updater": {
            "updater": 34
        }
    }


## Updater Flow
We have left the update process mostly to the mercy of the programmer, since updating configurations is mostly a direct process from the data store to the configuration folder. However, we will define some of the important data structures and discuss a likely control flow for updating. 

## 4 Updated Messages
There are 3 types of update messages the system understands, and are recommended to be used by programmers. There are: 

* remote_config_updated

* fetched_config

* local_config_updated

### remote_config_updated_message
This message is generated by some entity when a config in the remote storage is changed or added. 
This message content takes the form 

    {
        id: id of entity sending message 
        time: time_of_update
        config_folder: folder for config
        config_name: name of the config
        config_id: id of the config
    }

For example:

    {
        id: system_middle_agent_test
        time: TODO
        config_folder: addresses
        config_name: bmp280_in
        config_id: bmp280_in_gateway 
    }

### fetched_config
The fetched config message is very similar to the remote_config_updated message, except that it also includes the config_content

    {
        id: id of entity sending the message 
        time: time_of_update
        config_folder: folder for config
        config_name: name of the config
        config_id: id of the config
        config_content: {the dictionary content of the config }
    }

For example: 

    {
        id: system_middle_agent_test
        time: TODO
        config_folder: addresses
        config_name: bmp280_in
        config_id: bmp280_in_gateway 
        config_content: {TODO}
    }

### local_config_updated 
This message indicates that the updated config was written to a local storage. The message contains:

    {
        id: id of the system who wrote the config to storage
        time: time of message generation 
        config_folder: folder of the config
        config_name: name of the config 
        config_id: id of the config
    }

    For example:

    {
        id: test_system
        time: <TODO: Fill in >
        config_folder: addresses
        config_name: bmp280_in
        config_id: bmp_280_in
    }


## Suggested Control Flow 
Here is the control we suggest for an update system, and which we have implemented in MongoDB and MQTT.
1. When a config is changed, the remote_config_updated message is sent to the middle agent. If a config is added and/or an updater changed, these messages would ideally go through first. We recommend sending to the middle agent via MQTT

2. The remote_config_updated message should have an "on_message" trigger which activates a function that can get the updated config (like mongo). This same function posts a "fetched_config" message when completed. 

3. The "fetched_config" config message should have an on_message trigger to send it via mqtt to the gateways via MQTT

4. The "fetched_config" config message should have an on_message task trigger when received by the gateway to activate the update_config function. This function should check if the gateway cares about the message (in updater config). If it does, it should write the new config to an "await_configs" file. (Move here?) If successful, it should post local_config_updated message. 

5. The local_config updated message should have an on_message trigger on the gateway to send back to the middle agent via MQTT

6. The local_config updated message should have an on_message trigger on the middle agent to store in the database 


TODO: When do you actually pull in the new updates??? 
Maybe don't worry about right this second, but will need later 

In general, the only two configurations which might be unique across systems would be that system's configuration and that system's updater. 

To run a successful update, you would already need the necessary configurations for your updater logic. We recommend having a base install of configurations first, instead of relying exclusively on a updater to pull in initial configurations. 


## JSON switchover 
* imports
* updater file 
* mongo file should not change - it's storing a message rather than a config 